배열내장함수(기능, 복사본, 반환 값)

push()
  : ()안의 데이터를 원본 배열의 맨 끝 요소로 추가
    (ex) arr = ["짱구","흰둥이"]
        arr.push("신형만")
        arr = ["짱구","흰둥이","신형만"]

pop()
  :원본 배열의 맨 끝 요소를 삭제, 제거된 요소를 반환한다
    (ex) arr.pop()
        console.log(arr)
        //짱구, 흰둥이
        console.log(el)
        //신형만


unshift
  :()안의 데이터를 원본 배열의 맨 앞에 추가
  (ex) arr =[1,2,3,4]
  arr.unshift(0)
  //0.1,2,3,4


shift
  :원본 배열의 맨 앞 요소를 제거, 제거된 요소 반환


arr1.concat(arr2)
  : ()안의 두 배열을 함친 하나의 복사본 배열을 반환
  (ex) arr1 = [1,2,3,4]
  arr2 = [5,6,7,8]
  let concat = arr1.concat(arr2) //1,2,3,4,5,6,7,8 로 나오는데 arr1,arr2 원본에는 지장가지 않음
  (ex)인스타 같은 스크롤 이벤트? 같은 것에 이용
    스크롤 내리면 다른 게시글이 추가되고 추가되는 것 
  

join
  : ()안의 원하는 문자가 삽입된 문자열을 반환 
    (배열을 문자로 만들고싶을 때 주로 많이 쓰임 그냥 문자열로만 만들고싶다면 .join("")이라고 쓰면됨)
  (ex)const ph = ["010","1234","1234"]
  ph.join("-")
  //010-1234-1234 //사이에 - 문자가 추가됨


reverse
  : 원본 배열의 역순 배치
  arr=[1,2,3,4]
  arr.reverse() //4,3,2,1



split()
  :문자열을 ()안의 문자 기준으로 배열로 생성 
  (ex)str ="안녕하세요"
  str.split()//["안","녕","하","세","요"]

  "010-1234-1234".split("-")
  //["010","1234","1234"]


splice(start, count, item)
  : 원본배열의 요소를 제거
    제거한 부분의 item을 대체
    start: 인덱스 , count: 개수
    arr=[1,2,3,4,5,6,7]
    arr.splice(3,3,"hello")
    // [1,2,3,hello,7]


slice(start, end)
  : 원본배열의 특정 구간을 잘라서 복사본 생성
    splice와 달리 제거하지 않음
    start 부터 시작해서 end 직전(end를 포함하지 않는다)까지의 범위
    (ex) const arr = [1,2,3,4,5,6,7]
    let a = arr.slice(3,5)
    console.log(a) //4,5


  indexOf
    :배열에 특정한 값의 인덱스를 찾기 위해 사용
      이 배열에 해당 값이 포함되어 있는지 확인하기 위해 쓰였으나,
      현재는 includes 를 많이 사용한다

      내가 찾고자 하는 요소의 인덱스가 필요할 때 주로 사용

      a =[1,2,3,4,5,...100000]
      a.indexOf(5000) //배열의 index를 알려줌

  
  includes
    있는지 없는지 확인 유무
    분기처리할때 주로 사용한다(있다면~ 없다면~)
    : a.includes(1) //true or false


  


  ---------------------------------------------------------------------


  


  배열의 고차함수
    -매개변수로 콜백함수가 들어가는 경우가 많습니다
    -배열을 순회하는 경우가 많습니다
    -배열의 유틸 기능

  map
    : 배열을 순서대로 반복한다
    반복 시 마다 각 요소에 콜백함수의 반환 값을 요소로하는 '새로운 배열'을 생성
    (ex) const posts =[
      {
        id:1,
       title:안녕하세요1
      },
       {
        id:2,
        title:안녕하세요2
      }
    ]
    posts.map(()=>{})


  filter
    : 특정한 배열에서 내가 원하는 요소들만 찾아서 새로운 배열을 반환
    특정한 조건애 맞는 배열, 특정한 값을 삭제한 배열내장함수

    const userLinst = [
      {
      name: 이예진,
      age: 29,
      height: 163
      },{
      name: 김사과,
      age: 39,
      height: 173
      },{
      name: 최멜론,
      age: 24,
      height: 180
      }
    ]

    const filterUserList = userLinst.filter((el)=>{
      el.age > 20;
    })

    //삭제되는것
    //splices 는 원본 배열의 값을 삭제하지만
    //filter는 원본 배열의 값을 삭제하지 않고 새로운 복사본을 생성
    const deletedUserList = userLinst.filter((el)=>el.name !=="이예진")


  find
    :특정한 배열에서 특정한 조건을 만족하는 요소를 찾아서 반환
    배열을 순회, 조건식에 맞는 가장 첫번째 요소


  findIndex
    :find와 모든 원리가 같지만 index를 반환합니다
    값이 없다면 -1을 반환


  reduce
    : 순회, 누적값
    현재요소와 다음 요소, 연산된 누적값을 반환
    첫번째 순회시 누적값의 초기값은 첫번째 요소
    현재요소는 두번째 요소들만
    단 reduce의 두번째인자에 누적값의 기본값을 설정
    만약 누적값의 기본값이 있다면 sum은 기본값이 되고 n은 첫번째 요소

    (ex) 
    const numArr =[1,2,3,4,5,6,7,8,9,10]

    numArr.reduce((sum, n)=>{
    return sum+n;
    },0)

   // numArr.reduce((누적값, 현재요소)=>{
   //  return
   // })


    => 배열의 모든요소를 순회하면서 누적되는 값이 있다면 reduce를 고민
        다음 연산에 이전까지의 연산이 필요할 때



  every
    : 배열에서 모든 요소의 조건이 참인지 확인하는 것
    (ex) const arr = [2,4,6,8]
    arr.every((el)=>el%2===0)
    특정 조건이 모두 만족하느냐에 따라서 분기처리



  some
    : 배열에서 하나 이상의 요소가 참인지 확인하는 것, 분기처리할때 자주 사용
    (ex) const arr = [2,4,5,8,7]
    arr.some((el)=> el%2 ===1) //true // 만약 홀수인 경우가 하나라도 있어? 너 true

  
  sort
    : 원본 배열의 요소 크기대로 정렬
    (ex) const arr = [5,3,1,2,5]
    arr.sort() //1,2,3,4,5 




